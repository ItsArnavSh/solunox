#include "containers.h"
#include <iostream>

// Constructor for the containers class, initializing each Container with the appropriate TokenType
containers::containers(TokenType Sol, TokenType Luna, TokenType Nox) {
    this->sol = Container(Sol);
    this->luna = Container(Luna);
    this->nox = Container(Nox);
}

// Constructor for Container class to initialize type and head
Container::Container(TokenType type) : type(type), head(nullptr) {}

// Function to add an element based on the container type
void Container::add(int x) {
    if (type == STACK) {
        //std::cout << "Adding to Stack\n";
        push(x);
    } else if (type == QUEUE) {
        //std::cout << "Adding to Queue\n";
        enqueue(x);
    } else if (type == PRIORITYQUEUE) {
        //std::cout << "Adding to Priority Queue\n";
        priorityEq(x);
    }
}

// Function to remove an element based on the container type
void Container::remove() {
    if (type == STACK) {
        pop();
    } else if (type == QUEUE) {
        dequeue();
    } else if (type == PRIORITYQUEUE) {
        priorityDq();
    }
}

// Peek function to view the top/front element
int Container::peek() {
    if (head) {
        return head->data;
    } else {
        //std::cout << "Container is empty.\n";
        return -1;  // or throw an exception if desired
    }
}

// Push function to add an element to the top of the stack
void Container::push(int x) {
    //std::cout << "Pushing " << x << " onto Stack\n";
    node* newnode = new node(x);  // Using the node constructor to initialize

    if (!newnode) {
        std::cerr << "Memory allocation failed\n";
        return;
    }

    newnode->next = head;
    newnode->prev = nullptr;

    if (head) {
        head->prev = newnode;
    }

    head = newnode;
}

// Pop function to remove the top element from the stack
void Container::pop() {
    if (!head) {
        //std::cout << "Stack is empty. Cannot pop.\n";
        return;
    }
    node* temp = head;
    head = head->next;
    if (head) head->prev = nullptr;
    delete temp;
}

// Enqueue function to add an element to the end of the queue
void Container::enqueue(int x) {
    //std::cout << "Enqueueing " << x << " into Queue\n";
    node* newnode = new node(x);

    if (!head) {
        head = newnode;
    } else {
        node* temp = head;
        while (temp->next) temp = temp->next;
        temp->next = newnode;
        newnode->prev = temp;
    }
}

// Dequeue function to remove the front element from the queue
void Container::dequeue() {
    if (!head) {
        //std::cout << "Queue is empty. Cannot dequeue.\n";
        return;
    }
    node* temp = head;
    head = head->next;
    if (head) head->prev = nullptr;
    delete temp;
}

// Function to insert an element into the priority queue based on priority
void Container::priorityEq(int x) {
    //std::cout << "Inserting " << x << " into Priority Queue\n";
    node* newnode = new node(x);

    if (!head || head->data > x) {
        newnode->next = head;
        if (head) head->prev = newnode;
        head = newnode;
    } else {
        node* temp = head;
        while (temp->next && temp->next->data <= x) temp = temp->next;
        newnode->next = temp->next;
        if (temp->next) temp->next->prev = newnode;
        temp->next = newnode;
        newnode->prev = temp;
    }
}

// Function to dequeue (remove) the front element from the priority queue
void Container::priorityDq() {
    if (!head) {
        //std::cout << "Priority Queue is empty. Cannot dequeue.\n";
        return;
    }
    node* temp = head;
    head = head->next;
    if (head) head->prev = nullptr;
    delete temp;
}
#include <cstdlib>
#include <iostream>
#include "error.h"
void error(std::string err){
    std::cout << err<<std::endl;
    exit(EXIT_FAILURE);
}
#include "fileReader.h"
#include <stdexcept>

// Constructor that opens the file
FileReader::FileReader(const std::string& filePath) : file(filePath) {
    if (!file.is_open()) {
        throw std::runtime_error("Could not open file.");
    }
}

// Reads the next character from the file and updates last position
char FileReader::readNextChar() {
    char ch;
    if (file.get(ch)) {
        lastPosition = file.tellg();
        return ch;
    }
    return 0;
}

// Moves the file pointer backward by 'steps' characters
void FileReader::goBack(int steps) {
    std::streamoff newPos = static_cast<std::streamoff>(lastPosition) - steps;
    if (newPos >= 0) {
        file.seekg(newPos);
        lastPosition = file.tellg();
    } else {
        throw std::runtime_error("Cannot go back further.");
    }
}

// Moves the file pointer forward by 'steps' characters
void FileReader::goForward(int steps) {
    std::streamoff newPos = static_cast<std::streamoff>(lastPosition) + steps;
    file.seekg(newPos);
    lastPosition = file.tellg();
}

// Checks if the end of the file has been reached
bool FileReader::isEOF() {
    return file.eof();
}

// Gets the current file pointer position
std::streampos FileReader::getPosition() const {
    return lastPosition;
}
#include <iostream>
#include <vector>
#include "errorHandle.h"
#include "scanner.h"
#include "parser.h"
#include "walker.h"
int main(int argc, char** argv){
    if(argc!=2)
        error("Correct Syntax ./main <filename>");
    loadKeywords();

    std::vector<Token> tokens = Scanner(argv[1]);
    Parser parser(tokens);
    Node* root = parser.parseProgram();
   mainWalker(root);

}
#include "parser.h"
#include "token.h"
#include "errorHandle.h"
#include <unordered_set>
#include <iostream>
std::unordered_set<TokenType> allowedMajors;

void Node::addChild(Node* child) {
    children.push_back(child);
}

// Parser methods
bool Parser::match(TokenType type) {
    return current < tokens.size() && tokens[current].type == type;
}

Token Parser::consume(TokenType type, const std::string& errorMessage) {
    if (match(type)) return tokens[current++];
    error(errorMessage);
}

Token Parser::peek() {
    return tokens[current];
}

void debugger(const std::string& d) {}

Node* Parser::parseProgram() {
    debugger("PROGRAM");
    return parseFunctions();
}

Node* Parser::parseFunctions() {
    debugger("FUNCTIONS");
    Node* functions = new Node(FUNCTIONS);
    while (current < tokens.size()) {
        consume(DOLLAR, "Invalid Function Declaration");
        Token identifier = consume(FUNCTION, "FUNCTION NAME NOT FOUND");
        consume(COPEN, "FUNCTION BLOCK NOT OPENED");
        functions->addChild(parseFunction());
    }
    return functions;
}

Node* Parser::parseFunction() {
    debugger("FUNCTION");
    Node* function = new Node(FUNCTION);
    Token dec = consume(DECLARE, "Container Declaration not found");
    Node* declare = new Node(DECLARE, &dec);
    function->addChild(declare);
    function->addChild(parseStatements());
    return function;
}

Node* Parser::parseStatements() {
    debugger("STATEMENTS");
    Node* statements = new Node(STATEMENTS);
    while (!match(CCLOSE)) {
        if (match(IF)) {
            debugger("Reached If");
            statements->addChild(parseIf());
        }
        else if (match(LOOP)) {
            statements->addChild(parseLoop());
        }
        else if (match(CALLER)) {
            debugger("Function Call");
            consume(CALLER, "Function Call Operator Expected");
            Token name = consume(FUNCTION, "Function name Expected");
            Node* call = new Node(CALLER, &name);
            statements->addChild(call);
        }
        else if(match(BREAK)){
            Token name = consume(BREAK, "Break Expected");
            Node* call = new Node(BREAK, &name);
             statements->addChild(call);
        }
        else if(match(RETURN)){
            Token name = consume(RETURN, "Return Here");
            Node* call = new Node(RETURN, &name);
             statements->addChild(call);
        }
        else {
            statements->addChild(parseStatement());
        }
    }
    consume(CCLOSE, "Function not ended");
    return statements;
}

Node* Parser::parseIf() {
    debugger("IF");
    consume(IF, "Expected 'if'.");
    Node* ifNode = new Node(IF);
    consume(COPEN,"Expected {");
    debugger("reached Here");
    while(!match(CCLOSE)){
        debugger("Inside If Loop");
        Node* temp = new Node(CONDITION_BRANCH);
        //On the left, an expression
        temp->addChild(parseExpression());
        //On the right, a block
        temp -> addChild(parseBlock());
        ifNode->addChild(temp);
    }
    consume(CCLOSE,"Expected {");
    return ifNode;
}

Node* Parser::parseLoop() {
    debugger("LOOP");
    consume(LOOP, "Expected 'loop'.");
    Node* loop = new Node(LOOP);
    loop->addChild(parseBlock());
    return loop;
}

Node* Parser::parseBlock() {
    debugger("BLOCK");
    consume(COPEN, "Brackets Expected");
    return parseStatements();
}

Node* Parser::parseStatement() {
    debugger("STATEMENT");
    Token left;
    // Ensure identifier types are handled correctly
    if (match(SOL) || match(LUNA) || match(NOX) || match(CONSTAS) || match(OMNIS) || match(PRINT) || match(PRINTC)) {
        left = consume(peek().type, "Expected identifier.");
        Node* leftAssign = new Node(left.type, &left);

        // Add logic to handle assignment vs other operations
        if (match(EQUAL)|| match(LEFTPUSH)||match(RIGHTPUSH)||match(LEFTCOPY)||match(RIGHTCOPY)) {  // Assuming ASSIGN is the token for '=' or similar
            Node* assignmentNode = new Node(peek().type);
            consume(peek().type, "Expected major after identifier.");
            assignmentNode->addChild(leftAssign);
            Node* exp = parseExpression();

            if(match(EXPO)){
                consume(EXPO,"^ Expected");
                int iterations = consume(NUMBER,"Number Expected after ^").value.number;
                for(int i=0;i<iterations;i++)
                    assignmentNode->addChild(exp);
            }
            else {
                 assignmentNode->addChild(exp);
            }
            while(match(COMMA)){
                consume(COMMA,"Expected Comma");
                Node* exp = parseExpression();

                if(match(EXPO)){
                    consume(EXPO,"^ Expected");
                    int iterations = consume(NUMBER,"Number Expected after ^").value.number;
                    for(int i=0;i<iterations;i++)
                        assignmentNode->addChild(exp);
                }
                else {
                     assignmentNode->addChild(exp);
                }
            }
            return assignmentNode;
        } else {
            error("Incorrect Statement");
        }
    }

    // For standalone expressions (not assignments), parse normally
    Token curr = peek();
    current++;
    Node* statement = new Node(curr.type);

    // Add parsing for expression directly
    statement->addChild(parseExpression());
    return statement;
}



Node* Parser::parseExpression() {
    debugger("EXPRESSION");
    if(match(COPEN))
    {
        error("Unexpected { in expression");
        return nullptr;
    }
    return parseCompareSections();
}
Node* Parser::parseCompareSections(){
    Node* left = parseEquality();
    while (match(AND) || match(OR)) {
        Token operatorToken = tokens[current++];
        Node* right = parseEquality();
        Node* equalityNode = new Node(operatorToken.type == AND ? AND : OR);
        equalityNode->addChild(left);
        equalityNode->addChild(right);
        left = equalityNode;
    }
    return left;
}
Node* Parser::parseEquality() {
    debugger("EQUALITY");
    Node* left = parseComparison();
    while (match(EQUALEQUAL) || match(BANGEQUAL)) {
        Token operatorToken = tokens[current++];
        Node* right = parseComparison();
        Node* equalityNode = new Node(operatorToken.type == EQUALEQUAL ? EQUALEQUAL : BANGEQUAL);
        equalityNode->addChild(left);
        equalityNode->addChild(right);
        left = equalityNode;
    }
    return left;
}

Node* Parser::parseComparison() {
    debugger("COMPARISON");
    Node* left = parseTerm();
    while (match(GREATERTHAN) || match(GREATEREQUAL) || match(LESSTHAN) || match(LESSEQUAL)) {
        Token operatorToken = tokens[current++];
        Node* right = parseTerm();
        Node* comparisonNode;
        switch (operatorToken.type) {
            case GREATERTHAN:       comparisonNode = new Node(GREATERTHAN); break;
            case GREATEREQUAL: comparisonNode = new Node(GREATEREQUAL); break;
            case LESSTHAN:          comparisonNode = new Node(LESSTHAN); break;
            case LESSEQUAL:    comparisonNode = new Node(LESSEQUAL); break;
            default: throw std::runtime_error("Unexpected comparison operator.");
        }
        comparisonNode->addChild(left);
        comparisonNode->addChild(right);
        left = comparisonNode;
    }
    return left;
}

Node* Parser::parseTerm() {
    debugger("TERM");
    Node* left = parseFactor();
    while (match(PLUS) || match(MINUS)) {
        Token operatorToken = tokens[current++];
        Node* right = parseFactor();
        Node* termNode = new Node(operatorToken.type == PLUS ? PLUS : MINUS);
        termNode->addChild(left);
        termNode->addChild(right);
        left = termNode;
    }
    return left;
}

Node* Parser::parseFactor() {
    debugger("FACTOR");
    Node* left = parseUnary();
    while (match(MULTIPLY) || match(DIVIDE)) {
        Token operatorToken = tokens[current++];
        Node* right = parseUnary();
        Node* factorNode = new Node(operatorToken.type == MULTIPLY ? MULTIPLY : DIVIDE);
        factorNode->addChild(left);
        factorNode->addChild(right);
        left = factorNode;
    }
    return left;
}

Node* Parser::parseUnary() {
    debugger("UNARY");
    if (match(BANG) || match(MINUS)) {
        Token operatorToken = tokens[current++];
        Node* right = parseUnary();
        Node* unaryNode = new Node(operatorToken.type == BANG ? BANG : MINUS);
        unaryNode->addChild(right);
        return unaryNode;
    }
    return parsePrimary();
}
Node* Parser::parsePrimary() {
    debugger("Primary");

    if (match(NUMBER)) {
        Token number = consume(NUMBER, "Expected number.");
        return new Node(NUMBER, &number);
    }
    if (match(FUNCTION)) {
        Token identifier = consume(FUNCTION, "Expected function name.");
        return new Node(FUNCTION, &identifier);
    }
    if (match(SOL) || match(LUNA) || match(NOX) || match(CONSTAS) || match(OMNIS) || match(TRASH) || match(INPUT)) {
        return new Node(consume(peek().type, "Expected identifier.").type);
    }
    if (match(BOPEN)) {
        consume(BOPEN, "Expected '('.");
        Node* expr = parseExpression();
        consume(BCLOSE, "Expected ')'.");
        return expr;
    }

    // Improved handling for unexpected tokens, such as `CCLOSE`
    Token unexpected = peek();
    if (unexpected.type == CCLOSE) {
        error("Unexpected '}' encountered, possibly missing a previous '{'.");
    } else {
        error("Unexpected token in expression.");
    }
    return nullptr;
}
void Node::printTree(int indent = 0) {
    // Print indentation based on depth level
    for (int i = 0; i < indent; ++i) {
        std::cout << "  ";
    }

    // Print the token type of the current node
    std::cout << tokenTypeToString(type) << std::endl;

    // Recursively print each child node, increasing the indentation level
    for (Node* child : children) {
        child->printTree(indent + 1);
    }
}

// Helper function to convert TokenType to string (you'll need this for readable output)
std::string tokenTypeToString(TokenType type) {
    switch (type) {
        case PROGRAM: return "PROGRAM";
        case FUNCTIONS: return "FUNCTIONS";
        case FUNCTION: return "FUNCTION";
        case STATEMENTS: return "STATEMENTS";
        case STATEMENT: return "STATEMENT";
        case IF: return "IF";
        case LOOP: return "LOOP";
        case CALLER: return "CALLER";
        case DECLARE: return "DECLARE";
        case EQUALEQUAL: return "EQUALEQUAL";
        case BANG: return "BANG";
        case BANGEQUAL: return "BANGEQUAL";
        case LESSTHAN: return "LESSTHAN";
        case LESSEQUAL: return "LESSEQUAL";
        case GREATERTHAN: return "GREATERTHAN";
        case GREATEREQUAL: return "GREATEREQUAL";
        case PLUS: return "PLUS";
        case MINUS: return "MINUS";
        case DIVIDE: return "DIVIDE";
        case MULTIPLY: return "MULTIPLY";
        case EQUAL: return "EQUAL";
        case SOL: return "SOL";
        case LUNA: return "LUNA";
        case NOX: return "NOX";
        case CONSTAS: return "CONSTAS";
        case OMNIS: return "OMNIS";
        case NUMBER: return "NUMBER";
        case LEFTPUSH: return "LEFTPUSH";
        case LEFTCOPY: return "LEFTCOPY";
        case RIGHTPUSH: return "RIGHTPUSH";
        case RIGHTCOPY: return "RIGHTCOPY";
        default: return "UNKNOWN";
    }
}
#include "scanner.h"
#include "token.h"
#include <iostream>
#include <iterator>
#include <vector>
#include <cctype>
std::unordered_map<std::string,TokenType> keywords;
void loadKeywords(){
    keywords["input"] = INPUT;
    keywords["print"] = PRINT;
    keywords["sol"] = SOL;
    keywords["luna"] = LUNA;
    keywords["nox"] = NOX;
    keywords["constas"] = CONSTAS;
    keywords["omnis"] = OMNIS;
    keywords["if"] = IF;
    keywords["else"] = ELSE;
    keywords["loop"] = LOOP;
    keywords["trash"] = TRASH;
    keywords["break"] = BREAK;
    keywords["return"] = RETURN;
    keywords["and"] = AND;
    keywords["or"] = OR;
    keywords["printc"] = PRINTC;
}
std::vector<Token> Scanner(std::string filename) {
    loadKeywords();
    FileReader reader(filename);
    std::vector<Token> tokens;

    while (!reader.isEOF()) {
        char current = reader.readNextChar();

        switch (current) {
            case ',':
             tokens.push_back(Token(COMMA));
            break;
            case '\'':
            tokens.push_back(Token((short)reader.readNextChar()));
            reader.goForward();
            break;
            case '+':
                tokens.push_back(Token(PLUS));
                break;

            case '-':
                tokens.push_back(Token(MINUS));
                break;

            case '*':
                tokens.push_back(Token(MULTIPLY));
                break;

            case '/': {
                char next = reader.readNextChar();
                if (next == '/') {
                    // Skip the rest of the line for comments
                    while (next != '\n' && !reader.isEOF()) {
                        next = reader.readNextChar();
                    }
                } else {
                    reader.goBack(); // Move back if it's just '/'
                    tokens.push_back(Token(DIVIDE));
                }
                break;
            }

            case '=': {
                char next = reader.readNextChar();
                if (next == '=') {
                    tokens.push_back(Token(EQUALEQUAL));
                } else {
                    reader.goBack(); // Move back if it's just '='
                    tokens.push_back(Token(EQUAL));
                }
                break;
            }

            case '!': {
                char next = reader.readNextChar();
                if (next == '=') {
                    std::cout<<"NOT";
                    tokens.push_back(Token(BANGEQUAL));
                } else {
                    std::cout<<"Here";
                    reader.goBack(); // Move back if it's just '!'
                    tokens.push_back(Token(BANG));
                }
                break;
            }



            case '(':
                tokens.push_back(Token(BOPEN));
                break;

            case ')':
                tokens.push_back(Token(BCLOSE));
                break;

            case '{':
                tokens.push_back(Token(COPEN));
                break;

            case '}':
                tokens.push_back(Token(CCLOSE));
                break;

            case ';':
                tokens.push_back(Token(SEMICOLON));
                break;

            case '$':
                tokens.push_back(Token(DOLLAR));
                break;

            case '@':
                tokens.push_back(Token(CALLER));
                break;
            case '<': {
                char next = reader.readNextChar();
                if (next == '~') {
                    tokens.push_back(Token(LEFTPUSH));
                } else if (next == '<') {
                    tokens.push_back(Token(LEFTCOPY));
                } else if (next == '=') {
                    tokens.push_back(Token(LESSEQUAL));
                } else {
                    reader.goBack(); // Move back if it's just '<'
                    tokens.push_back(Token(LESSTHAN));
                }
                break;
            }
            case '^':
            tokens.push_back(Token(EXPO));
            break;
            case '>': {
                char next = reader.readNextChar();
                if (next == '>') {
                    tokens.push_back(Token(RIGHTCOPY));
                } else if (next == '=') {
                    tokens.push_back(Token(GREATEREQUAL));

                } else {
                    reader.goBack(); // Move back if it's just '>'
                    tokens.push_back(Token(GREATERTHAN));
                }
                break;
            }
                case '"':{
                    char ch = reader.readNextChar();
                    tokens.push_back((short)ch);
                        do{
                        ch = reader.readNextChar();
                        tokens.push_back(COMMA);
                        tokens.push_back(ch);
                    }while(ch != '"');
                    tokens.pop_back();
                    tokens.pop_back();
                }
                break;
                case ':':{
                    std::string pattern = "";
                    pattern+=reader.readNextChar();
                    pattern+=reader.readNextChar();
                    pattern+=reader.readNextChar();
                    short k=0;
                    if(reader.readNextChar()==':'){
                        for(auto cont:pattern){
                            switch(cont){
                                case 's':{
                                    k = k*3+0;
                                    break;
                                }
                                case 'q':{
                                    k = k*3+1;
                                    break;
                                }
                                case 'p':{
                                    k=k*3+2;
                                    break;
                                }
                                default:{
                                    error("Invalid Container Initialization");
                                    break;
                                }

                            }
                        }
                        tokens.push_back(Token(DECLARE,k));
                    }
                    else{
                        error("Invalid Container Initialization");
                    }
                    break;
                }
                case '~': {
                    if(reader.readNextChar()=='>'){
                        tokens.push_back(RIGHTPUSH);
                    }
                    break;
                }


                break;
            default:
                // Handle numbers
                if (std::isdigit(current)) {
                    int number = current - '0';
                    char next = reader.readNextChar();
                    while (!reader.isEOF() && std::isdigit(next)) {
                        number = number * 10 + (next - '0');
                        next = reader.readNextChar();
                    }
                    reader.goBack(); // Step back one character
                    tokens.push_back(Token(number));
                }
                // Handle identifiers and keywords
                else if (std::isalpha(current) || current == '_') {
                    std::string identifier;
                    identifier += current;
                    char next = reader.readNextChar();
                    while (!reader.isEOF() && (std::isalnum(next) || next == '_')) {
                        identifier += next;
                        next = reader.readNextChar();
                    }
                    reader.goBack(); // Step back one character
                    if (keywords.find(identifier)!=keywords.end()) {
                        tokens.push_back(Token(keywords[identifier]));

                    } else {
                        if(identifier=="main"){
                            mainLocation = counter;
                        }
                        tokens.push_back(Token(identifier)); // Treat as a general identifier
                    }
                }
                break;
        }
    }

    return tokens;
}
#include "token.h"
#include <algorithm>
#include "error.h"

short counter = 0;  // Initialize counter
std::unordered_map<short, std::string> functions;
short mainLocation = -1;
Token::Token(TokenType type) {
    this->type = type;
    this->value.empty = nullptr;
}

Token::Token(std::string literal) {
    this->type = FUNCTION;

    // Check if literal already exists in the map to avoid duplicate entries
    auto it = std::find_if(functions.begin(), functions.end(),[&literal](const auto& pair) { return pair.second == literal; });

    if (it != functions.end()) {
        this->value.identifierKey = it->first; // Use existing key
    } else {
        functions[counter] = literal;         // Add new functions
        this->value.identifierKey = counter;
        counter++;
    }
}
Token::Token (TokenType type,int number){
    this->type = type;
    this->value.number = number;
}
Token::Token(int number) {
    this->type = NUMBER;
    this->value.number = number;
}
Token::Token (TokenType type,std::string str){
    this->type = DECLARE;

}
#include <iostream>
#include "token.h"

void Token::printToken() {
    // Print token type
    switch (type) {
        case PLUS:
            std::cout << "Token Type: PLUS";
            break;
        case MINUS:
            std::cout << "Token Type: MINUS";
            break;
        case DIVIDE:
            std::cout << "Token Type: DIVIDE";
            break;
        case MULTIPLY:
            std::cout << "Token Type: MULTIPLY";
            break;
        case EQUAL:
            std::cout << "Token Type: EQUAL";
            break;
        case FUNCTION:
            std::cout << "Token Type: FUNCTION";
            std::cout << ", Value: " << value.identifierKey;
            break;
        case SEMICOLON:
            std::cout << "Token Type: SEMICOLON";
            break;
        case BOPEN:
            std::cout << "Token Type: BOPEN (";
            break;
        case BCLOSE:
            std::cout << "Token Type: BCLOSE )";
            break;
        case NUMBER:
            std::cout << "Token Type: NUMBER, Value: " << value.number;
            break;
        case BANG:
            std::cout << "Token Type: BANG (!)";
            break;
        case EQUALEQUAL:
            std::cout << "Token Type: EQUALEQUAL (==)";
            break;
        case BANGEQUAL:
            std::cout << "Token Type: BANGEQUAL (!=)";
            break;
        case LESSTHAN:
            std::cout << "Token Type: LESSTHAN (<)";
            break;
        case LESSEQUAL:
            std::cout << "Token Type: LESSEQUAL (<=)";
            break;
        case GREATERTHAN:
            std::cout << "Token Type: GREATERTHAN (>)";
            break;
        case GREATEREQUAL:
            std::cout << "Token Type: GREATEREQUAL (>=)";
            break;
        case COPEN:
            std::cout << "Token Type: COPEN ({)";
            break;
        case CCLOSE:
            std::cout << "Token Type: CCLOSE (})";
            break;
        case DOLLAR:
            std::cout << "Token Type: DOLLAR ($)";
            break;
        case CALLER:
            std::cout << "Token Type: CALLER (@)";
            break;

        // Keywords
        case TRASH:
            std::cout << "Token Type: TRASH";
            break;
        case IF:
            std::cout << "Token Type: IF";
            break;
        case ELSE:
            std::cout << "Token Type: ELSE";
            break;
        case LOOP:
            std::cout << "Token Type: LOOP";
            break;
        case INPUT:
            std::cout << "Token Type: INPUT";
            break;
        case PRINT:
            std::cout << "Token Type: PRINT";
            break;
        case SOL:
            std::cout << "Token Type: SOL";
            break;
        case LUNA:
            std::cout << "Token Type: LUNA";
            break;
        case NOX:
            std::cout << "Token Type: NOX";
            break;
        case CONSTAS:
            std::cout << "Token Type: CONSTAS";
            break;
        case OMNIS:
            std::cout << "Token Type: OMNIS";
            break;

        // Special tokens
        case DECLARE:
            std::cout << "Token Type: DECLARE (~abc~)";
            break;
        case LEFTPUSH:
            std::cout << "Token Type: LEFTPUSH (<-)";
            break;
        case RIGHTPUSH:
            std::cout << "Token Type: RIGHTPUSH (->)";
            break;
        case LEFTCOPY:
            std::cout << "Token Type: LEFTCOPY (<<)";
            break;
        case RIGHTCOPY:
            std::cout << "Token Type: RIGHTCOPY (>>)";
            break;

        default:
            std::cout << "Unknown Token Type";
    }
    std::cout << std::endl;
}
#include "walker.h"
#include "containers.h"
#include "token.h"
#include <cstddef>
#include <iostream>
#include <stack>
std::stack<bool> loopFlags;//For Keeping track of break statements in nested if-loops
std::stack<bool> functionFlags;
std::stack<containers> functionStack;
std::stack<int> omnis;
Node* root;
void mainWalker(Node *nt){
    root = nt;
    if(mainLocation==-1){
        error("No Main Function found");
    }
    solveFunction(nt->children[mainLocation]);
    std::cout << std::endl;
}
TokenType DivideAndConquor(short num){
    switch(num){
        case 0:
            return STACK;
        case 1:
            return QUEUE;
        case 2:
            return PRIORITYQUEUE;
        default:
            error("Error in validation");
            return FUNCTION;
    }
}
void solveFunction(Node* start){
    if(start->children.size()==0){
        error("Function Not Found");
    }
    functionFlags.push(false);

    int num = start->children[0]->value.number;
    //std::cout << num<<std::endl;
    //mod 3 once -> nox
    short n = num%3;
    num = num/3;
    short l = num%3;
    num = num/3;
    short s = num%3;
    containers func(DivideAndConquor(s),DivideAndConquor(l),DivideAndConquor(n));
    functionStack.push(func);
    //start[2] is statements
    solveStatements(start->children[1]);
    functionStack.pop();//Remove Function from stack after operation
    functionFlags.pop();
}
void solveStatements(Node* start){
    for(auto *statement : start->children){
        solveAnyStatement(statement);
        if(functionFlags.top())
            return;

    }
}
void solveAnyStatement(Node* statement) {
    switch (statement->type) {
        case CALLER:
            solveFunction(root->children[statement->value.identifierKey]);
            break;
        case LOOP:
            solveLoop(statement->children[0]);
            break;
        case IF:
            solveIF(statement);
            break;
        case BREAK:
            if(loopFlags.empty())
                error("No loops for break statement");
            loopFlags.top() = true;
            break;
        case RETURN:
            functionFlags.top()=true;
            return;
        default:
            solveStatement(statement);  // Handle other statements like assignments
            break;
    }
}
void solveIF(Node* start){
    for(auto condition:start->children){
        if(eval(condition->children[0])){

            solveStatements(condition->children[1]);
            for(auto *statement : condition->children[1]->children){
                solveAnyStatement(condition);
                if(functionFlags.top())
                    return;
            }
            break;
        }
    }
}
void solveLoop(Node* start){
    loopFlags.push(false);
    while(true){
        for(auto *statement : start->children){
            solveAnyStatement(statement);
            if(functionFlags.top())
                return;
            if(loopFlags.top())
                break;
            }
            if(loopFlags.top())
                break;
        }
        loopFlags.pop();
    }

void popper(Node* start){
    switch(start->children[1]->type){
        case SOL:
        functionStack.top().sol.pop();
        break;
        case LUNA:
        functionStack.top().luna.pop();
        break;
        case NOX:
        functionStack.top().nox.pop();
        case OMNIS:
        omnis.pop();
        default:
        return;

    }
}
void solveStatement(Node* start){
    Node* leftOperand = start->children[0];
    for(int i=1;i<start->children.size();i++){

    switch(start->type){
        case EQUAL:
        switch(start->children[0]->type){
        case SOL:
        functionStack.top().sol.remove();
        functionStack.top().sol.add(eval(start->children[i]));
        break;
        case LUNA:
        functionStack.top().luna.remove();
        functionStack.top().luna.add(eval(start->children[i]));
        break;
        case NOX:
        functionStack.top().luna.remove();
        functionStack.top().nox.add(eval(start->children[i]));
        break;
        case PRINT:
        std::cout<<eval(start->children[i])<<std::endl;
        popper(start);
        break;
        case PRINTC:
        std::cout<<char(eval(start->children[i])%128);
        popper(start);
        break;
        case OMNIS:
        functionStack.top().sol.remove();
        omnis.push(eval(start->children[i]));
        break;
        default:
        error("Container or Print Expected");
        }
        break;
        case LEFTPUSH:
        switch(start->children[0]->type){
        case SOL:
        functionStack.top().sol.add(eval(start->children[i]));
        popper(start);
        break;
        case LUNA:
        functionStack.top().luna.add(eval(start->children[i]));
        popper(start);
        break;
        case NOX:
        functionStack.top().nox.add(eval(start->children[i]));
        popper(start);
        break;
        case PRINT:
        std::cout<<eval(start->children[i])<<std::endl;
        popper(start);
        break;
        case PRINTC:
        std::cout<<char(eval(start->children[i])%128);
        popper(start);
        break;
        case OMNIS:
        omnis.push(eval(start->children[i]));
        popper(start);
        break;
        default:
        error("Container or Print Expected");
        }
        break;
        case LEFTCOPY:
        switch(start->children[0]->type){
        case SOL:
        functionStack.top().sol.add(eval(start->children[i]));
        break;
        case LUNA:
        functionStack.top().luna.add(eval(start->children[i]));
        break;
        case NOX:
        functionStack.top().nox.add(eval(start->children[i]));
        break;
        case PRINT:
        std::cout<<eval(start->children[i])<<std::endl;
        break;
        case PRINTC:
        std::cout<<char(eval(start->children[i])%128);
        break;
        case OMNIS:
        omnis.push(eval(start->children[i]));
        break;
        }
        break;
        case RIGHTPUSH:
        if(start->children[i]->type==TRASH){

            popper(start);
        }
        else{
            error("Expected TRASH Keyword");
        }
        break;
    }
    }
}

int eval(Node* nt) {
    switch (nt->type) {
        case AND:
            return eval(nt->children[0]) && eval(nt->children[1]);
        case OR:
            return eval(nt->children[0]) || eval(nt->children[1]);
        case EQUALEQUAL:
            return eval(nt->children[0]) == eval(nt->children[1]);

        case BANG:
            return !eval(nt->children[0]);

        case LESSTHAN:
            return eval(nt->children[0]) < eval(nt->children[1]);

        case LESSEQUAL:
            return eval(nt->children[0]) <= eval(nt->children[1]);

        case GREATERTHAN:
            return eval(nt->children[0]) > eval(nt->children[1]);

        case GREATEREQUAL:
            return eval(nt->children[0]) >= eval(nt->children[1]);

        case PLUS:
            return eval(nt->children[0]) + eval(nt->children[1]);

        case MINUS:
            return eval(nt->children[0]) - eval(nt->children[1]);

        case DIVIDE:
            return eval(nt->children[0]) / eval(nt->children[1]);

        case MULTIPLY:
            return eval(nt->children[0]) * eval(nt->children[1]);

        case NUMBER:
            return nt->value.number;  // Replace with the appropriate member if different

        case SOL:
            return functionStack.top().sol.peek();

        case LUNA:
            return functionStack.top().luna.peek();

        case NOX:
            return functionStack.top().nox.peek();
        case INPUT:
            int inp;
            std::cin >> inp;
            return inp;
            case OMNIS:
                if (!omnis.empty()) {
                    return omnis.top();
                } else {
                    error("Omnis stack is empty");
                    return -1;
                }

        default:
            error("Error in evaluation");
            return -1;
    }
}
#ifndef CONTAINERS_H
#define CONTAINERS_H
#include "token.h"
class node{
    public:
    int data;
    node* next;
    node* prev;
    node(){}
    node(int data){this->data = data;next = nullptr;prev = nullptr;}
};
class Container{
    TokenType type;
    node* head;
    public:
    Container() : head(nullptr) {}
    Container(TokenType type);
    void add(int x);
    void remove();
    int peek();
    void push(int x);
    void pop();
    void enqueue(int x);
    void dequeue();
    void priorityEq(int x);
    void priorityDq();
};
class containers{
    public:
    Container sol,luna,nox;
    containers(TokenType Sol,TokenType Luna,TokenType Nox);
};
#endif
#include <string>
void error(std::string err);
// FileReader.h
#ifndef FILEREADER_H
#define FILEREADER_H

#include <fstream>
#include <string>

class FileReader {
public:
    // Constructor
    FileReader(const std::string& filePath);

    // Reads the next character from the file
    char readNextChar();

    // Moves the file pointer backward by 'steps' characters
    void goBack(int steps = 1);

    // Moves the file pointer forward by 'steps' characters
    void goForward(int steps = 1);

    // Checks if the end of the file is reached
    bool isEOF();

    // Gets the current file pointer position
    std::streampos getPosition() const;

private:
    std::ifstream file;
    std::streampos lastPosition = 0;
};

#endif // FILEREADER_H
#ifndef  PARSER_H
#define PARSER_H
#include "token.h"
#include "error.h"
#include <cstddef>
#include <stdexcept>
#include <string>
#include <vector>
class Node {
public:
    TokenType type;
    Storage value;
    std::vector<Node*> children;

    // Constructor for non-terminal nodes
    Node(TokenType type) : type(type) {}

    // Constructor for terminal nodes (tokens)
    Node(TokenType type, Token* token) : type(type), value(token->value) {}

    void addChild(Node* child);
    void printTree(int indent);
};

class Parser{
    public:
    std::vector<Token> tokens;
    uint current = 0;
    Parser(std::vector<Token> tokens): tokens(tokens){};
    bool match(TokenType type);
    Token consume(TokenType type, const std::string& errorMessage);
    Token peek();
    Node* parseProgram();
    Node* parseFunctions();
    Node *parseFunction();
    Node* parseStatements();
    Node* parseStatement();
    Node* parseBlock();
    Node* parseOperator();
    Node* parseLoop();
    Node* parseIf();
    Node* parseExpression();
    Node* parseCompareSections();
    Node* parseEquality();
    Node* parseComparison();
    Node* parseTerm();
    Node* parseFactor();
    Node* parseUnary();
    Node* parsePrimary();
};
std::string tokenTypeToString(TokenType);
#endif
#include "token.h"
#include <cstdio>
#include <vector>
#include <fstream>
#include "fileReader.h"
#include "errorHandle.h"
std::vector<Token> Scanner(std::string filename);
void loadKeywords();
#ifndef SCOPE_H
#define SCOPE_H
//Here we will define the scope
#include "containers.h"
#include <stack>
extern std::stack<containers> functionStack;

#endif
#ifndef TOKEN_H
#define TOKEN_H

#include <cstdint>
#include <string>
#include <unordered_map>


// Union to store different token values
typedef union Storage {
    int number;
    void* empty;
    short identifierKey;

} Storage;

// Global counter for new identifier keys
extern short counter;
extern short mainLocation;//Saves the index of the main function
// Map to store identifier strings
extern std::unordered_map<short, std::string> functions;

// Enumeration for token types
typedef enum TokenType {
    //NODES
    PROGRAM,
    FUNCTIONS,
    STATEMENT,
    STATEMENTS,
    //
    PLUS,//+
    MINUS,//-
    DIVIDE,///
    MULTIPLY,//*
    EQUAL,//=
    FUNCTION,//functionname
    SEMICOLON,//;
    BOPEN,//(
    BCLOSE,//)
    NUMBER,
    BANG,
    EQUALEQUAL,//==
    BANGEQUAL,//!=
    LESSTHAN,//<
    LESSEQUAL,//<=
    GREATERTHAN,//>
    GREATEREQUAL,//>=
    COPEN,//{
    CCLOSE,//}
    DOLLAR,//$
    CALLER,//@
    AND, //and
    OR, //or
    RETURN,
    //KEYWORDS
    IF,
    ELSE,
    LOOP,
    INPUT,
    PRINT,
    SOL,
    LUNA,
    NOX,
    CONSTAS,
    OMNIS,
    TRASH,

    //SPECIAL
    DECLARE,//~abc~ //abc can be 123, all 9 values are saved as numbers
    LEFTPUSH,//<- <~4
    RIGHTPUSH,//-> ~4~>
    LEFTCOPY,//<< <<~4~
    RIGHTCOPY,//>>
    CONDITION_BRANCH,
    DEFAULT,
    //
    STACK,
    QUEUE,
    PRIORITYQUEUE,
    BREAK,
    PRINTC,
    COMMA,
    EXPO
} TokenType;

class Token {
public:
    TokenType type;
    Storage value;

    // Constructors for different token types
    Token(){}
    Token(TokenType type);           // For operators
    Token(std::string literal);      // For identifiers (sets identifierKey)
    Token(int number);               // For numbers (sets number)
    Token (TokenType type,int number);//For push and copy values
    Token (TokenType type,std::string str);
    void printToken();
};

#endif
#ifndef WALKER_H
#define WALKER_H
#include "parser.h"
#include "errorHandle.h"
#include "token.h"
#include "scope.h"
#include <iostream>
void mainWalker(Node* nt);
void solveFunction(Node* start);
void solveStatements(Node* start);
void solveIF(Node* start);
void solveLoop(Node* start);
void solveAnyStatement(Node* statement);
void solveStatement(Node* start);
int eval(Node* nt);
void printAll();
#endif
